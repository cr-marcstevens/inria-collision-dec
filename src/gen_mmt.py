#!/usr/bin/env python

## \file gen_mmt.py
#Generate code of the sub_isd module using May, Meurer & Thomae algorithm
#
#Parameters p is set as first parameter of the command line. It must multiple of 4.

import os
import sys

def repeat(format, start, end, sep):
	return sep.join([format % (i) for i in range(start, end + 1)])

try:
	ncols=int(sys.argv[1])
except:
	sys.stderr.write('usage : ' +sys.argv[0]+' ncols\n')
	sys.exit(1)

if(ncols%4 != 0):
	sys.stderr.write('p must be multiple of 4')
	sys.exit(2)

o = ""


o += """/* FILE GENERATED BY %s */""" % os.path.basename(sys.argv[0])

o += """

#include <stdio.h>
#include <stdlib.h>
#include "libisd.h"
#include "sub_isd.h"
#include "final_test.h"
#include "measure.h"
#include "ciht.h"
#include "support.h"
"""

o += "#define P %d" % (ncols)

o += """
static word* L;
static unsigned int N;
static word* syndsprime;
static unsigned int n, k, r, l, l2, alpha, w, L_len, threshold;
static sw_list** h;

unsigned int L0_support_len;
word* L0_support;
unsigned int L1_support_len;
word* L1_support;
unsigned int L2_support_len;
word* L2_support;
unsigned int L3_support_len;
word* L3_support;

static unsigned int L0_size, L2_size, L01_size;
static ciht_t L0 = NULL;
static ciht_t L2 = NULL;
static ciht_t L01 = NULL;
"""

o += """
void print_parameters(isd_params* params) {
	printf("n : %d\\n", params->n);
	printf("r : %d\\n", params->r);
	printf("w : %d\\n", params->w);
	printf("l : %d\\n", params->l);
	printf("l2 : %d\\n", params->l2);
	printf("alpha : %d\\n", params->alpha);
	printf("p : %d\\n", params->p);
	printf("eff_word_len : %ld\\n", min(params->r, word_len));
	printf("threshold : %d\\n", params->weight_threshold);
}
"""

o += """
void sub_isd_init(isd_params* params, word* local_L, word* local_synds, unsigned int local_N, sw_list** local_h, ranctx* state) {
	params->p = P;
	(void) state;
	print_parameters(params);
	L = local_L;
	N = local_N;
	syndsprime = local_synds;
	h = local_h;

	n = params->n;
	r = params->r;
	k = params->k;
	l = params->l;
	l2 = params->l2;
	alpha = params->alpha;
	w = params->w;

	L_len = k+l;

	threshold = params->weight_threshold;

	if(alpha > l2) {
		alpha = l2;
	}

	prepare_half0(&L0_support, &L0_support_len, L_len);
	prepare_half1(&L1_support, &L1_support_len, L_len);
	prepare_quarter0and2(&L2_support, &L2_support_len, L_len);
	prepare_quarter1and3(&L3_support, &L3_support_len, L_len);

	L0_size = 1UL << l2;
	L2_size = 1UL << l2;
	L01_size = 1ULL<<(l-l2);

	L0 = ciht_init(L0_size, P/4, 0);
	L2 = ciht_init(L2_size, P/4, 0);
	L01 = ciht_init(L01_size, P/2, 0);
}
"""

o += """
void sub_isd() {
	word synd = syndsprime[0]; //DOOM not implemented
"""
for L in ["L0", "L1", "L2", "L3"]:
	o += "	ci_t %s;\n" % (repeat(L+"_c%d", 0, ncols/4-1, ", "))

o += """
	unsigned int weight_on_one_word;
	int final_weight;
	word a;
	const int l2shift = word_len - l2;
	const int ll2shift = word_len - (l-l2); 
	word index;
	word value;

#ifdef COUNT_DISTINCTS
	fprintf(stderr, "WARNING : Counting distincts candidates\\n");
	sw_list* l_distincts = NULL;
#endif

	// setup the supports by copying the corresponding parts of L in new lists.
	build_half0(L0_support, L, L_len);
	build_half1(L1_support, L, L_len);
	build_quarter0and2(L2_support, L, L_len);
	build_quarter1and3(L3_support, L, L_len);

	ciht_reset(L0, L0_size, P/4);
"""
o += "	for (L0_c0 = %d; L0_c0 < L0_support_len; ++L0_c0) {\n" % (ncols/4-1)

for i in range(1,ncols/4):
	o += "	for (L0_c%d = %d; L0_c%d < L0_c%d; ++L0_c%d) {\n" % (i, ncols/4-i-1, i, i-1, i)

o += """		value = 0\n"""
for i in range(ncols/4):
	o += "			^ L0_support[L0_c%d]\n" % (i)
o += "		;"

o +="""
		index = value >> l2shift;
"""
o += "		ci_t t[P/4] = {%s};" % (repeat("L0_c%d", 0, ncols/4-1, ", "))
o += """
		ciht_store(L0, index, t, P/4);
"""
for i in range(1, ncols/4):
	o += "	}\n"
o += "	}\n"


o += """	ciht_reset(L2, L2_size, P/4);
"""

o += "	for (L2_c0 = %d; L2_c0 < L2_support_len; ++L2_c0) {\n" % (ncols/4-1)
for i in range(1,ncols/4):
	o += "	for (L2_c%d = %d; L2_c%d < L2_c%d; ++L2_c%d) {\n" % (i, ncols/4-i-1, i, i-1, i)

o += """		value = 0\n"""
for i in range(ncols/4):
	o += "			^ L2_support[L2_c%d]\n" % (i)
o += "		;"

o +="""
		index = value >> l2shift;
"""
o += "		ci_t t[P/4] = {%s};" % (repeat("L2_c%d", 0, ncols/4-1, ", "))
o += """
		ciht_store(L2, index, t, P/4);
"""
for i in range(1, ncols/4):
	o += "	}\n"
o += "	}\n"

o += """

	for (a = 0; a < (1UL << (l2-alpha)); ++a) {
		ciht_reset(L01, L01_size, P/2);
"""
o += "		for (L1_c0 = %d; L1_c0 < L1_support_len; ++L1_c0) {\n" % (ncols/4-1)
for i in range(1,ncols/4):
	o += "		for (L1_c%d = %d; L1_c%d < L1_c%d; ++L1_c%d) {\n" % (i, ncols/4-i-1, i, i-1, i)

o += """		value = 0\n"""
for i in range(ncols/4):
	o += "			^ L1_support[L1_c%d]\n" % (i)
o += "		;"

o +="""
			index = value >> l2shift;
			index ^= a;
			ci_t* t0 = ciht_get(L0, index, P/4);
"""
o += """
			if(t0) {
"""
for i in range(ncols/4):
	o += "				L0_c%d = t0[%d];\n" % (i, i)

o += """		value = value\n"""
for i in range(ncols/4):
	o += "			^ L0_support[L0_c%d]\n" % (i)
o += "		;"

o +="""
				index = (value << l2) >> ll2shift;
"""
o += "				ci_t t01[P/2] = {"
o += repeat("L0_c%d", 0, ncols/4-1, ", ")
o += ", "
o += repeat("L1_c%d", 0, ncols/4-1, ", ")
o += "};"
o += """
				ciht_store(L01, index, t01, P/2);
			}
"""
for i in range(1, ncols/4):
	o += "		}\n"
o += "		}\n"

o += "		for (L3_c0 = %d; L3_c0 < L3_support_len; ++L3_c0) {\n" % (ncols/4-1)
for i in range(1,ncols/4):
	o += "		for (L3_c%d = %d; L3_c%d < L3_c%d; ++L3_c%d) {\n" % (i, ncols/4-i-1, i, i-1, i)

o += """		value = synd\n"""
for i in range(ncols/4):
	o += "			^ L3_support[L3_c%d]\n" % (i)
o += "		;"

o +="""
			index = value >> l2shift;
			index ^= a;
			ci_t* t2 = ciht_get(L2, index, P/4);
			if(t2) {
"""
for i in range(ncols/4):
  o += "				L2_c%d = t2[%d];\n" % (i, i)

o += """		value = value\n"""
for i in range(ncols/4):
	o += "			^ L2_support[L2_c%d]\n" % (i)
o += "		;"

o+= """
				index = ((value) << l2) >> ll2shift;
				ci_t* t01 = ciht_get(L01, index, P/2);
				if (t01) {
"""
for i in range(ncols/4):
  o += "					L0_c%d = t01[%d];\n" % (i, i)
for i in range(ncols/4):
  o += "					L1_c%d = t01[%d];\n" % (i, i)
	
o += """
					incr_collision_counter();
#ifdef COUNT_DISTINCTS
					(void) weight_on_one_word;
					(void) final_weight;
"""
o += """					ci_t candidate[P] = {
"""
for i in range(ncols/4):
	o += "						inv_half0(L0_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "						inv_half1(L1_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "						inv_quarter0and2(L2_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "						inv_quarter1and3(L3_c%d, L_len),\n" % (i)
o += "					};"
o += """
					sw_list_append(&l_distincts, sw_filled_new_array(0, 0, P, candidate));
#else
"""

o += """		value = value\n"""
for i in range(ncols/4):
	o += "			^ L0_support[L0_c%d]\n" % (i)
for i in range(ncols/4):
	o += "			^ L1_support[L1_c%d]\n" % (i)
o += "		;"

o += """
					weight_on_one_word = isd_weight(value);
					if(weight_on_one_word < threshold) {
						bday_cycle_stopwatch_stop();
						incr_final_test_counter();
						final_test_cycle_stopwatch_start();

"""
o += """						ci_t candidate[P] = {
"""
for i in range(ncols/4):
	o += "							inv_half0(L0_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "							inv_half1(L1_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "							inv_quarter0and2(L2_c%d, L_len),\n" % (i)
for i in range(ncols/4):
	o += "							inv_quarter1and3(L3_c%d, L_len),\n" % (i)
o += """
						};
						final_weight = final_test_array(0, weight_on_one_word, P, candidate);
						if (final_weight != -1) {
							sw_list_append(h, sw_filled_new_array(0, final_weight, P, candidate));
						}
						final_test_cycle_stopwatch_stop();
						bday_cycle_stopwatch_start();
					}
#endif
				}
			}
"""
for i in range(1, ncols/4):
	o += "		}\n"
o += "		}\n"
o += """ }
	sw_list_uniq(h);
#ifdef COUNT_DISTINCTS
	printf("Distincts : %d\\n", sw_list_uniq(&l_distincts));
#endif
}
"""

o += """
void sub_isd_free() {
	free(L0_support);
	free(L1_support);
	free(L2_support);
	free(L3_support);
	ciht_free(L0);
	ciht_free(L2);
	ciht_free(L01);
}
"""

print o
