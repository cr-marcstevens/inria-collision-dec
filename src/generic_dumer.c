/* FILE GENERATED BY gen_dumer.py */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <m4ri/m4ri.h>
#include "sub_isd.h"
#include "libisd.h"
#include "ciht.h"
#include "support.h"
#include "final_test.h"
#include "sparse_words_list.h"
#include "measure.h"
#include "syscall_macros.h"
static word* L;
static unsigned int N;
static word* syndsprime;
static unsigned int n, k, r, l, p, w, L_len, threshold;
static unsigned int lprime;
static int shift;

static ci_t* L0_c;
static ci_t* L1_c;
static word* subsums;

unsigned int L0_support_len;
word* L0_support;
unsigned int L1_support_len;
word* L1_support;

static unsigned int L0_size;
static ciht_t L0;

static sw_list** h;

ci_t* candidate;

void print_parameters(isd_params* params) {
	printf("n : %d\n", params->n);
	printf("r : %d\n", params->r);
	printf("w : %d\n", params->w);
	printf("l : %d\n", params->l);
	printf("p : %d\n", params->p);
	printf("eff_word_len : %ld\n", min(params->r, word_len));
	printf("threshold : %d\n", params->weight_threshold);
}

/**
 * \brief Updates t such that it contains the next p-uplet among the nCr(max, p)
 * \return biggest indices of modified slot in t. -1 if last p-uplet reached.
 */
int next(ci_t* t, int p, unsigned int max) {
	int i = p-1;
	while ((i >= 0) && (t[i] >= max-p+i)) {
		--i;
	}
	if (i < 0) {
		return -1;
	}
	int l = i;
	++t[i];
	for (i = i+1; i < p; ++i) {
		t[i] = t[i-1]+1;
	}
	return l;
}

void sub_isd_init(isd_params* params, word* local_L, word* local_synds, unsigned int local_N, sw_list** local_h, ranctx* state) {
	(void) state;
	print_parameters(params);
	L = local_L;
	N = local_N;
	syndsprime = local_synds;
	h = local_h;

	n = params->n;
	r = params->r;
	k = params->k;
	l = params->l;
	p = params->p;
	w = params->w;

	L_len = k+l;

	threshold = params->weight_threshold;

	unsigned long long nb_of_sums = nCr(L_len/2, p/2);

	// lprime can be used to tune hash table size. It should be less than or equal to l. Best case is when the table fits in the cache. 
	// Lowering lprime will rise hash table occupation ratio hence intern collision probability. That means it will reduce number of generated candidates if table collisions are discarded.
	lprime = (l+ log(nb_of_sums)/log(2))/2;
	lprime = l;
	printf("lprime : %d\n", lprime);

	shift = min(r, word_len) - lprime;

	L0_c = (ci_t*) malloc((p/2)*sizeof(unsigned int));
	L1_c = (ci_t*) malloc((p/2)*sizeof(unsigned int));
	subsums = (word*) malloc((p/2+1)*sizeof(word));

	prepare_half0(&L0_support, &L0_support_len, L_len);
	prepare_half1(&L1_support, &L1_support_len, L_len);

	L0_size = 1ULL << lprime;
	L0 = ciht_init(L0_size, p/2, 0);

	candidate = (ci_t*) malloc(p*sizeof(ci_t));
}


void sub_isd() {
	word synd = syndsprime[0]; //DOOM not implemented
	int lidx;
	unsigned int i;

	word index;
	word value;

	unsigned int weight;
	int final_weight;
	const word max_word_zero_l_bits = 1UL << (word_len - l); /* A word with its l MSB zeroed is lower than this value */

#ifdef SORT_L
	qsort(L, L_len/2, sizeof(word), word_cmp);
	qsort(L+L_len/2, L_len - L_len/2, sizeof(word), word_cmp);
#endif

	build_half0(L0_support, L, L_len);
	build_half1(L1_support, L, L_len);

	ciht_reset(L0, L0_size, p/2);

	for (i = 0; i < p/2; ++i) {
		L0_c[i] = i;
	}

	subsums[0] = 0;

	lidx = 0; 
	while (lidx != -1) {
		for (i = lidx; i < p/2; ++i) {
			subsums[i+1] = subsums[i] ^ L0_support[L0_c[i]];
		}

		value = subsums[p/2];
		index = value >> shift;
		ciht_store(L0, index, L0_c, p/2);
		lidx = next(L0_c, p/2, L0_support_len);
	}

	for (i = 0; i < p/2; ++i) {
		L1_c[i] = i;
	}
	subsums[0] = synd;
	lidx = 0;
	while (lidx != -1) {
		for (i = lidx; i < p/2; ++i) {
			subsums[i+1] = subsums[i] ^ L1_support[L1_c[i]];
		}
		value = subsums[p/2];
		index = value >> shift;
		ci_t* t0 = ciht_get(L0, index, p/2);
		if (t0) {
			for (i = 0; i < p/2; ++i) {
				value ^= L0_support[t0[i]];
			}
			incr_collision_counter();
			
			weight = isd_weight(value);
			if (weight < threshold) {
				bday_cycle_stopwatch_stop();
				incr_final_test_counter();
				final_test_cycle_stopwatch_start();
				for (i = 0; i < p/2; ++i) {
					candidate[i] = inv_half0(t0[i], L_len);
				}
				for (i = 0; i < p/2; ++i) {
					candidate[i+p/2] = inv_half1(L1_c[i], L_len);
				}

				final_weight = final_test_array(0, weight, p, candidate);
				if (final_weight != -1) {
					sw_list_append(h, sw_filled_new_array(0, final_weight, p, candidate));
				}
				final_test_cycle_stopwatch_stop();
				bday_cycle_stopwatch_start();
			}	
		}
		lidx = next(L1_c, p/2, L1_support_len);
	}
}

void sub_isd_free() {
	free(L0_support);
	free(L1_support);
	ciht_free(L0);
}

