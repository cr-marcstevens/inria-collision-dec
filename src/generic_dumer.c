/* FILE GENERATED BY gen_dumer.py */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "sub_isd.h"
#ifdef MANAGE_COL
	#warning Managing collisions
	#if	MANAGE_COL == 2
		#include "counterht_col2.h"
	#else
		#include "counterht_col.h"
	#endif
#else
	#include "counterht.h"
#endif
#include <m4ri/m4ri.h>
#include "libisd.h"
#include "final_test.h"
#include "sparse_words_list.h"
#include "measure.h"
#include "syscall_macros.h"
static word* L;
static unsigned int N;
static word* syndsprime;
static unsigned int n, k, r, l, p, w, L_len, threshold;
static unsigned int lprime;
static int shift;

static unsigned int* indices;
static word* subsums;

static unsigned int L0_size;
static counterht L0;
static word* xors_table;

static sw_list** h;

static unsigned short* final_test_input;

static short** unpack;

void unpack_counter(unsigned int* c1, unsigned int* c2, counter c) {
	*c1 = unpack[c][0];
	*c2 = unpack[c][1];
}

void unpack_counter_array(unsigned short* t, counter c, unsigned int p) {
	unsigned int i;
	for (i = 0; i < p; ++i) {
		t[i] = unpack[c][i];
	}
}

void print_parameters(isd_params* params) {
	printf("n : %d\n", params->n);
	printf("r : %d\n", params->r);
	printf("w : %d\n", params->w);
	printf("l : %d\n", params->l);
	printf("p : %d\n", params->p);
	printf("eff_word_len : %ld\n", min(params->r, word_len));
	printf("threshold : %d\n", params->weight_threshold);
}

/**
 * \brief Updates t such that it contains the next p-uplet among the nCr(max, p)
 * \return biggest indices of modified slot in t. -1 if last p-uplet reached.
 */
int next(unsigned int* t, int p, unsigned int max) {
	if (p == 0) {
		return -1;
	}
	if (t[p-1] != max-1) {
		++t[p-1];
		return p-1;
	}
	int lidx = next(t, p-1, max-1);
	if (lidx != -1) {
		t[p-1] = t[p-2] + 1;
	}
	return lidx;
}

void sub_isd_init(isd_params* params, word* local_L, word* local_synds, unsigned int local_N, sw_list** local_h, ranctx* state) {
	(void) state;
	print_parameters(params);
	L = local_L;
	N = local_N;
	syndsprime = local_synds;
	h = local_h;

	n = params->n;
	r = params->r;
	k = params->k;
	l = params->l;
	p = params->p;
	w = params->w;

	L_len = k+l;

	threshold = params->weight_threshold;

	unsigned long long nb_of_sums = nCr(L_len/2, p/2);

	// lprime can be used to tune hash table size. It should be less than or equal to l. Best case is when the table fits in the cache. 
	// Lowering lprime will rise hash table occupation ratio hence intern collision probability. That means it will reduce number of generated candidates if table collisions are discarded.
	lprime = (l+ log(nb_of_sums)/log(2))/2;
	lprime = l;
	printf("lprime : %d\n", lprime);

	shift = min(r, word_len) - lprime;

	indices = (unsigned int*) malloc((p/2)*sizeof(unsigned int));
	subsums = (word*) malloc((p/2+1)*sizeof(word));

	L0_size = 1ULL << lprime;
	L0 = counterht_init(L0_size, nb_of_sums);

	xors_table = (word*) MALLOC(nb_of_sums * sizeof(word));

	unsigned int i;

	counter c = 0;
	unpack = (short**) MALLOC(nb_of_sums * sizeof(short*));
	for (i = 0; i < nb_of_sums; ++i) {
		unpack[i] = (short*) MALLOC(p/2 * sizeof(short));
	}

	/*
	for (c1 = 1; c1 < L_len/2; ++c1) {
	for (c2 = 0; c2 < c1; ++c2) {
		unpack[c][0] = c1;
		unpack[c][1] = c2;
		++c;
	}}
	*/

	for (i = 0; i < p/2; ++i) {
		indices[i] = i;
	}

	int lidx = 0; 
	c = 0;
	while (lidx != -1) {
		for (i = 0; i < p/2; ++i) {
			unpack[c][i] = indices[i];
		}
		++c;
		lidx = next(indices, p/2, L_len/2);
	}

	final_test_input = (unsigned short*) malloc(p*sizeof(unsigned short));
}


void sub_isd() {
	word synd = syndsprime[0]; //DOOM not implemented
	unsigned int c1, c2, c3, c4;
	int lidx;
	unsigned int i;

	counter c;
	counter_container* ccont;
	word index;
	word value;
	/* Intermediate sums */

	unsigned int weight;
	int final_weight;
	const word max_word_zero_l_bits = 1UL << (word_len - l); /* A word with its l MSB zeroed is lower than this value */


#ifdef SORT_L
	qsort(L, L_len/2, sizeof(word), word_cmp);
	qsort(L+L_len/2, L_len - L_len/2, sizeof(word), word_cmp);
#endif

	counterht_reset(L0, L0_size);

	for (i = 0; i < p/2; ++i) {
		indices[i] = i;
	}

	subsums[0] = 0;

	lidx = 0; 
	c = 0;
	while (lidx != -1) {
		for (i = lidx; i < p/2; ++i) {
			subsums[i+1] = subsums[i] ^ L[indices[i]];
		}

		value = subsums[p/2];
		index = value >> shift;
		counterht_store(L0, index, c);
		xors_table[c] = value;
		++c;
		lidx = next(indices, p/2, L_len/2);
	}

	for (i = 0; i < p/2; ++i) {
		indices[i] = L_len/2+i;
	}
	subsums[0] = synd;
	lidx = 0;
	while (lidx != -1) {
		for (i = lidx; i < p/2; ++i) {
			subsums[i+1] = subsums[i] ^ L[indices[i]];
		}
		value = subsums[p/2];
		index = value >> shift;
		for(ccont = counterht_get(L0, index); ccont != NULL; ccont = counterht_next(L0, index, ccont)) {
			c = counter_container_open(ccont);
			value ^= xors_table[c];
			if (value < max_word_zero_l_bits) {
				incr_collision_counter();
				weight = isd_weight(value);
				if (weight < threshold) {
					bday_cycle_stopwatch_stop();
					incr_final_test_counter();
					final_test_cycle_stopwatch_start();
					unpack_counter(&c1, &c2, c);
					unpack_counter_array(final_test_input, c, p/2);
					for (i = 0; i < p/2; ++i) {
						final_test_input[i+p/2] = indices[i];
					}
					
					final_weight = final_test_array(0, weight, p, final_test_input);
					if (final_weight != -1) {
						sw_list_append(h, sw_filled_new_array(0, final_weight, p, final_test_input));
					}
					final_test_cycle_stopwatch_stop();
					bday_cycle_stopwatch_start();
				}	
			}
		}
		lidx = next(indices, p/2, L_len);
	}
}

void sub_isd_free() {
	unsigned long long nb_of_sums = nCr(L_len/2, p/2);
	unsigned long long i;
	for (i = 0; i < nb_of_sums; ++i) {
		free(unpack[i]);
	}
	free(unpack);
	counterht_free(L0);
	free(xors_table);
}

