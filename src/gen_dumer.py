#!/usr/bin/env python

import os
import sys

def repeat(format, nb, sep):
	return sep.join([format % (i) for i in range(1, nb + 1)])

try:
	ncols=int(sys.argv[1])
except:
	sys.stderr.write('usage : ' +sys.argv[0]+' ncols\n')
	sys.exit(1)

if(ncols%2 != 0):
	sys.stderr.write('p must be even')
	sys.exit(2)

output = ""

output += """/* FILE GENERATED BY %s */\n\n""" % os.path.basename(sys.argv[0])

output += """#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "sub_isd.h"
#include "counterht.h"
#include "m4ri/m4ri.h"
#include "libisd.h"
#include "final_test.h"
#include "sparse_words_list.h"
#include "measure.h"
#include "syscall_macros.h"
"""

output += "#define P %d" % (ncols)

output += """
static word* L;
static unsigned int N;
static word* syndsprime;
static unsigned int n, k, r, l, w, L_len, threshold;
static unsigned int lprime;
static int shift;

static unsigned int L0_size;
static counterht L0;
static word* xors_table;

static sw_list** h;

static short** unpack;
"""

output += """
void unpack_counter(""" + repeat("unsigned int* c%d", ncols/2, ", ") +", counter c) {\n"

for i in range(ncols/2):
	output += "	*c%d = unpack[c][%d];\n" % (i+1, i)
output += "}\n"

output += """
void print_parameters(isd_params* params) {
	printf("n : %d\\n", params->n);
	printf("r : %d\\n", params->r);
	printf("w : %d\\n", params->w);
	printf("l : %d\\n", params->l);
	printf("p : %d\\n", params->p);
	printf("eff_word_len : %ld\\n", min(params->r, word_len));
	printf("threshold : %d\\n", params->weight_threshold);
}

void sub_isd_init(isd_params* params, word* local_L, word* local_synds, unsigned int local_N, sw_list** local_h, ranctx* state) {
	params->p = P;
	(void) state;
	print_parameters(params);
	L = local_L;
	N = local_N;
	syndsprime = local_synds;
	h = local_h;

	n = params->n;
	r = params->r;
	k = params->k;
	l = params->l;
	w = params->w;

	L_len = k+l;

	threshold = params->weight_threshold;

	unsigned long long nb_of_sums = nCr(L_len/2, P/2);
	lprime = (l+ log(nb_of_sums)/log(2))/2;
	printf("lprime : %d\\n", lprime);

	shift = min(r, word_len) - lprime;

	L0_size = 1ULL << lprime;
	L0 = counterht_init(L0_size);

	xors_table = (word*) MALLOC(nb_of_sums * sizeof(word));

	unsigned int i;
"""
output += "	unsigned int " + repeat("c%d", ncols/2, ", ") + ";\n"
output += """
	counter c = 0;
	unpack = (short**) MALLOC(nb_of_sums * sizeof(short*));
	for (i = 0; i < nb_of_sums; ++i) {
		unpack[i] = (short*) MALLOC(P/2 * sizeof(short));
	}
"""
output += "	for (c1 = %d; c1 < L_len/2; ++c1) {\n" % (ncols/2-1)
for i in range(2,1+ncols/2):
	output += "	for (c%d = %d; c%d < c%d; ++c%d) {\n" % (i, ncols/2-i, i, i-1, i)
for i in range(ncols/2):
	output += "		unpack[c][%d] = c%d;\n" % (i, i+1)
output +="		++c;\n\t"

for i in range(ncols/2):
	output += "}"
output += "}\n\n"





output += """
void sub_isd() {
	word synd = syndsprime[0]; //DOOM not implemented
"""

output += "	unsigned int " + repeat("c%d", ncols, ", ") +";\n"
output += """
	counter c;
	word index;
	word value;
"""

output += """/* Intermediate sums */\n"""
for i in range(1, ncols/2+1):
	output += "	word sum" + "".join([str(i) for i in range(1, i+1)]) + ";\n"
for i in range(1, ncols/2+1):
	output += "	word sumS" + "".join([str(i) for i in range(ncols/2+1,ncols/2+i+1)]) + ";\n"

output += """
	unsigned int weight;
	int final_weight;
	word max_word_zero_l_bits = 1UL << (word_len - l); /* A word with its l MSB zeroed is lower than this value */

	counterht_reset(L0, L0_size);
	c = 0;
"""

output += "	for (c1 = %d; c1 < L_len/2; ++c1) {\n" % (ncols/2-1)
output += "		sum1 = L[c1];\n"

for i in range(2,1+ncols/2):
	output += "	for (c%d = %d; c%d < c%d; ++c%d) {\n" % (i, ncols/2-i, i, i-1, i)
	output += "		sum" + "".join([str(j) for j in range(1,i+1)]) + " = sum"  + "".join([str(j) for j in range(1,i)]) + " ^ L[c%d];\n" % (i)

output += "		value = sum" + "".join([str(j) for j in range(1,i+1)]) +";"
output += """
		index = value >> shift;
		counterht_store(L0, index, c);
		xors_table[c] = value;
		++c;
	"""
for i in range(ncols/2):
	output += "}"

output += "\n\n"

output += "	for (c%d = L_len/2 + %d; c%d < L_len; ++c%d) {\n" % (ncols/2+1, ncols/2-1, ncols/2+1, ncols/2+1)
output += "		sumS%d = synd ^ L[c%d];\n" %(ncols/2+1, ncols/2+1)

for i in range(2+ncols/2,1+ncols):
	output += "	for (c%d = L_len/2 + %d; c%d < c%d; ++c%d) {\n" % (i, ncols-i, i, i-1, i)
	output += "		sumS" + "".join([str(j) for j in range(ncols/2 + 1,i+1)]) + " = sumS"  + "".join([str(j) for j in range(ncols/2 + 1,i)]) + " ^ L[c%d];\n" % (i)

output += "		value = sumS" + "".join([str(j) for j in range(ncols/2 + 1,i+1)]) + ";"

output += """
		index = value >> shift;
		for(c = counterht_get(L0, index); c != NONE; c = counterht_next(L0, index, c)) {
			value ^= xors_table[c];
			if (value < max_word_zero_l_bits) {
				incr_collision_counter();
				weight = isd_weight(value);
				if (weight <= threshold) {
					bday_probe_stop();
					incr_final_test_counter();
					final_test_probe_start();
"""

output += "					unpack_counter(" + repeat("&c%d", ncols/2, ", ") +", c);\n"
output += "					final_weight = final_test(0, weight, P, " + repeat("c%d", ncols, ", ") +");"
output += """
					if (final_weight != -1) {
"""
output += "						*h = sw_list_add(*h, 0, final_weight, P, " + repeat("c%d", ncols, ", ") + ");"
output += """
					}
					final_test_probe_stop();
					bday_probe_start();
				}	
			}
		}
		"""
for i in range(ncols/2):
	  output += "}"

output += "}\n"

output += """
void sub_isd_free() {
	free(L0);
	free(xors_table);
}
"""

print output
